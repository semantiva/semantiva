# Copyright 2025 Semantiva authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import Any, Dict, Tuple, Type, Optional

import numpy as np

from semantiva.data_io.data_io import DataSource
from semantiva.data_processors.data_processors import DataOperation
from semantiva.data_types import NoDataType, DataCollectionType


class ParametricSweepFactory:
    """Factory for creating parametric sweep data operations.

    This factory produces DataOperation classes that generate collections of data
    by systematically varying independent parameters over specified ranges. The
    generated operation takes a DataSource and produces a DataCollection of the
    respective output data type.

    Generated Operation Behavior:
    ----------------------------
    The created DataOperation class:
    1. Takes NoDataType as input (requires no input data)
    2. Produces a DataCollectionType containing multiple data elements
    3. Each element is generated by calling the DataSource with different parameter values
    4. Parameter values are computed by varying independent variables over linear ranges
    5. Mathematical expressions can derive additional parameters from independent variables
    6. Static parameters remain constant across all generated elements
    7. Parameter sequences are stored in the pipeline context for downstream access

    Use Cases:
    ----------
    - Parameter studies and sensitivity analysis
    - Generating synthetic datasets with controlled variations
    - Monte Carlo simulations with systematic parameter exploration
    - Batch data generation for machine learning training sets

    Context Integration:
    -------------------
    The generated operation automatically injects parameter sequences into the
    pipeline context using keys formatted as "{variable_name}_values". These
    sequences contain the actual parameter values used during generation and
    can be accessed by subsequent pipeline operations.

    Mathematical Expression Evaluation:
    ----------------------------------
    Parametric expressions are evaluated using Python's eval() function within
    a controlled namespace. Expressions can reference independent variables by
    name and use standard mathematical operations and functions.

    Thread Safety:
    --------------
    Generated operations are thread-safe for read-only access. The factory
    itself is stateless and thread-safe.

    Example:
    --------
    ```python
    # Create a sweep operation class
    SweepOp = ParametricSweepFactory.create(
        element_source=MyDataSource,
        collection_output=MyDataCollection,
        independent_vars={"t": (0.0, 1.0), "amplitude": (10, 100)},
        parametric_expressions={"frequency": "2 * t + 1"},
        num_steps=50,
        static_params={"sampling_rate": 1000}
    )

    # Use in pipeline
    operation = SweepOp()
    result = operation.process(NoDataType())  # Returns MyDataCollection with 50 elements
    ```
    """

    @staticmethod
    def create(
        element_source: Type[DataSource],
        collection_output: Type[DataCollectionType],
        independent_vars: Dict[str, Tuple[float, float]],
        parametric_expressions: Dict[str, str],
        num_steps: int,
        static_params: Optional[Dict[str, Any]] = None,
        name: Optional[str] = None,
    ) -> Type[DataOperation]:
        """Create a parametric sweep DataOperation class.

        Produces a DataOperation subclass that generates a collection of data elements
        by systematically varying parameters and calling the specified DataSource.
        Each generated element represents one point in the parameter space.

        Args:
            element_source: DataSource subclass used to generate individual data elements.
                           Called once per parameter combination with computed parameters.
            collection_output: DataCollectionType subclass for storing generated elements.
                              Must be compatible with element_source output type.
            independent_vars: Dictionary mapping variable names to (min, max) ranges.
                             Variables are varied linearly using np.linspace over num_steps.
                             Example: {"time": (0.0, 10.0), "amplitude": (1, 100)}
            parametric_expressions: Dictionary mapping parameter names to mathematical expressions.
                                   Expressions are evaluated with independent variables in scope.
                                   Example: {"frequency": "2 * time + 1", "phase": "amplitude / 10"}
            num_steps: Number of parameter combinations to generate. Must be > 1.
                      Determines resolution of parameter space exploration.
            static_params: Fixed parameters passed to DataSource unchanged across all elements.
                          Merged with computed dynamic parameters for each call.
            name: Optional class name for generated operation. Defaults to
                 "{element_source.__name__}ParametricSweep".

        Returns:
            DataOperation subclass configured for the specified parametric sweep.
            The class takes NoDataType input and produces collection_output type.

        Raises:
            TypeError: If element_source is not a DataSource subclass or
                      collection_output is not a DataCollectionType subclass.
            ValueError: If independent_vars is empty or num_steps <= 1.

        Generated Operation Characteristics:
        -----------------------------------
        - Input Type: NoDataType (no input data required)
        - Output Type: Specified collection_output type
        - Context Keys: "{variable}_values" for each independent variable
        - Parameter Evaluation: Expressions evaluated using Python eval()
        - Parameter Order: static_params overridden by dynamic parameters

        Example Usage:
        --------------
        ```python
        # Define sweep parameters
        SweepClass = ParametricSweepFactory.create(
            element_source=SignalDataSource,
            collection_output=SignalCollection,
            independent_vars={"t": (0, 1), "freq": (1, 10)},
            parametric_expressions={"amplitude": "100 * t", "phase": "freq * 2"},
            num_steps=20,
            static_params={"sampling_rate": 1000}
        )

        # Use in pipeline
        sweep_op = SweepClass()
        signal_collection = sweep_op.process(NoDataType())
        # Results in 20 signals with varying t, freq, amplitude, and phase
        ```
        """

        if not issubclass(element_source, DataSource):
            raise TypeError("element_source must be a DataSource subclass")
        if not issubclass(collection_output, DataCollectionType):
            raise TypeError("collection_output must be a DataCollectionType subclass")
        if not independent_vars:
            raise ValueError("independent_vars must be non-empty")
        if num_steps <= 1:
            raise ValueError("num_steps must be greater than 1")

        class_name = name or f"{element_source.__name__}ParametricSweep"

        class ParametricSweep(DataOperation):
            """Dynamically created parametric sweep operation.

            This operation generates a collection of data elements by systematically
            varying independent parameters over specified ranges and calling the
            configured DataSource for each parameter combination.

            Operation Flow:
            1. Generate linear sequences for each independent variable using np.linspace
            2. Store parameter sequences in pipeline context as "{variable}_values"
            3. For each step: evaluate expressions, merge with static params, call DataSource
            4. Collect all generated elements into the specified collection type

            Context Updates:
            - Injects "{variable}_values" arrays for each independent variable
            - Arrays contain the actual parameter values used during generation
            - Available for downstream operations and analysis
            """

            _element_source = element_source
            _collection_output = collection_output
            _independent_vars = independent_vars
            _parametric_expressions = parametric_expressions
            _num_steps = num_steps
            _static_params = static_params or {}

            @classmethod
            def input_data_type(cls) -> Type[NoDataType]:
                """Return the input data type for this operation."""
                return NoDataType

            @classmethod
            def output_data_type(cls) -> Type[DataCollectionType]:
                """Return the output data type for this operation."""
                return cls._collection_output

            @classmethod
            def context_keys(cls):
                """Return context keys that will be created during sweep execution.

                Returns:
                    List of context key names in format "{variable}_values" for
                    each independent variable. These keys contain the parameter
                    sequences used during data generation.
                """
                return [f"{var}_values" for var in cls._independent_vars]

            def _process_logic(
                self, data: NoDataType, *args, **kwargs
            ) -> DataCollectionType:
                """Execute parametric sweep by generating parameter sequences and calling DataSource.

                Algorithm:
                1. Generate linear parameter sequences using np.linspace for each independent variable
                2. Store sequences in pipeline context as "{variable}_values" arrays
                3. Create lambda functions from parametric expressions for dynamic evaluation
                4. For each step (0 to num_steps-1):
                   a. Extract current parameter values from sequences
                   b. Evaluate parametric expressions with current values
                   c. Merge static parameters with dynamic parameters
                   d. Call DataSource.get_data() with merged parameters
                   e. Append generated element to collection
                5. Return collection containing all generated elements

                Args:
                    data: NoDataType input (ignored, sweep requires no input data)

                Returns:
                    DataCollectionType containing num_steps generated data elements

                Context Side Effects:
                    Injects "{variable}_values" arrays for each independent variable
                    containing the actual parameter values used during generation.
                """
                sequences = {
                    var: np.linspace(lo, hi, self._num_steps)
                    for var, (lo, hi) in self._independent_vars.items()
                }
                for var, seq in sequences.items():
                    self._notify_context_update(f"{var}_values", seq)

                # names of the sweep variables, e.g. "t, x, y"
                arg_list = ", ".join(self._independent_vars.keys())
                funcs = {
                    name: eval(f"lambda {arg_list}: {expr}", {}, {})
                    for name, expr in self._parametric_expressions.items()
                }

                elements = []
                for i in range(self._num_steps):
                    current = {var: sequences[var][i] for var in sequences}
                    dynamic = {name: func(**current) for name, func in funcs.items()}
                    params = {**self._static_params, **dynamic}
                    elements.append(self._element_source.get_data(**params))
                return self._collection_output.from_list(elements)

        ParametricSweep.__name__ = class_name
        ParametricSweep.__doc__ = (
            f"Parametric sweep data operation for {element_source.__name__} "
            f"producing {collection_output.__name__}."
        )

        return ParametricSweep
